## RecyclerView的缓存机制是什么，它和ListView的最大不同是什么？
 [Bugly-Android ListView 与 RecyclerView 对比浅析--缓存机制](https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&mid=2653578065&idx=2&sn=25e64a8bb7b5934cf0ce2e49549a80d6&chksm=84b3b156b3c43840061c28869671da915a25cf3be54891f040a3532e1bb17f9d32e244b79e3f&scene=21##wechat_redirect)

 [RecyclerView 必知必会](https://mp.weixin.qq.com/s/CzrKotyupXbYY6EY2HP_dA)
 
ListView分为两级缓存：
- mActiveViews：用于屏幕内Item快速滑动重用。
- mScrapViews:：用于缓存Adapter内的Item，在Adapter被替换时，mScrapViews就会被清空。

RecyclerView分为四级缓存：
- mAttachedScrap：和mActiveViews功能类似，用于屏幕内Item快速滑动重用。
- mCacheViews：和mScrapViews功能类似，在Adapter被替换时，mCacheViews会被缓存到RecyclerPool。
- mViewCacheExtension：用户自定义缓存。
- mRecyclerPool：mCache不用的会放进这里，还可以多个RecyclerView共用一个mRecyclerPool。

## RecycleView如何优化？
 [RecyclerView 性能优化](https://blankj.com/2018/09/29/optimize-recycler-view/)

## 为什么要使用MultiDex?MultiDex的执行流程？
 [MultiDex（一）之源码解析](https://www.jianshu.com/p/e164ee033928)

MultiDex启动流程:
 - MultiDex入口：MultiDex.install();
 - 进行各种预校验以及获取需要的信息；
 - 重要方法：MultiDexExtractor.load(context, e, dexDir, false)，将Dex文件提取出来。
 - 重要方法：installSecondaryDexes(loader, dexDir, files)，安装提取出来的Dex文件。
 - 制性提取或者源文件发生变化则重新提取，否则直接使用缓存dex文件。
 - 准备Dex缓存的目录，并且删除其中不是以name.apk.classes开头的文件；
 - 每个Dex的提取最多尝试三次；
 - 将Apk源文件进行解压，将其中的非主Dex文件提取为zip文件。
 - 反射获取ClassLoader中的pathList字段；
 - 反射调用DexPathList对象中的makeDexElements方法，将刚刚提取出来的zip文件包装成Element对象；
 - 将包装成的Element对象扩展到DexPathList中的dexElements数组字段里；
 - makeDexElements中有dexopt的操作，是一个耗时的过程，产物是一个优化过的odex文件。
 

## MultiDex对启动速度有什么影响?需要做什么优化？
> [MultiDex（二）之Dex预加载优化](https://www.jianshu.com/p/2891599511ff)

MultiDex为了解决65535问题，会使得app变得卡顿。

App第一次启动时单独开一个额外优化的进程率先进行Dex提取以及DexOpt的操作，与此同时主进程在后台等待，优化的进程执行完毕之后通知主进程继续往下执行，主进程在执行MultiDex.install时发现已经是提前优化好了Dex，直接执行，非常快，毫秒级别，不会造成卡顿，愉快的往下继续执行。

## intent最大传递数据有限制？限制为多少？如果有限制，有什么好的解决方案么？
1MB，把文件写在暂时文件或者数据库。

## 为什么binder在通信时，为什么只需要一次拷贝？
Binder的map函数，会将内核空间直接与用户空间对应，用户空间可以直接访问内核空间的数据
A进程的数据会被直接拷贝到B进程的内核空间（一次拷贝）

## Android的IPC方式
1.bundle ：
简单易用  但是只能传输Bundle支持的对象 常用于四大组件间进程间通信 
2.文件共享：
简单易用  但不适合在高并发的情况下 并且读取文件需要时间 不能即时通信   常用于并发程度不高 并且实时性要求不高的情况
3.AIDL ：
功能强大 支持一对多并发通信 支持即时通信   但是使用起来比其他的复杂 需要处理好多线程的同步问题  常用于一对多通信 且有RPC 需求的场合(服务端和客户端通信)
4.Messenger ：
功能一般 支持一对多串行通信 支持实时通信  但是不能很好处理高并发情况 只能传输Bundle支持的类型  常用于低并发的无RPC需求一对多的场合 
5.ContentProvider ：
在数据源访问方面功能强大 支持一对多并发操作 可扩展call方法  可以理解为约束版的AIDL  提供CRUD操作和自定义函数  常用于一对多的数据共享场合
6.Socket ：
功能强大 可以通过网络传输字节流 支持一对多并发操作  但是实现起来比较麻烦 不支持直接的RPC   常用于网络数据交换

当仅仅是跨进程的四大组件间的传递数据时 使用Bundle就可以  简单方便  
当要共享一个应用程序的内部数据的时候  使用ContentProvider实现比较方便  
当并发程度不高  也就是偶尔访问一次那种 进程间通信 用Messenger就可以  
当设计网络数据的共享时  使用socket 
当需求比较复杂  高并发 并且还要求实时通信 而且有RPC需求时  就得使用AIDL了 
文件共享的方法用于一些缓存共享 之类的功能 

## 匿名内部类，访问外部局部变量，为什么要用final修饰
内部类创建的对象的生命期会超过局部变量，不能让局部变量作用域扩大

## Android 进程间如何高效的传递较大数据块

## transform api和apt,各有什么实用场景，能否相互替换，相互补充？

## Android p限制访问hidden api大致原理？如何绕过？
> [Android P 调用隐藏API限制原理](https://mp.weixin.qq.com/s?__biz=MzUxODQ3MTk5Mg==&mid=2247483899&idx=1&sn=b471ce18b425696dfc5d9805328f1794&chksm=f98929accefea0ba5ecbf0917b71a5cb223f4d875eb769da35740ddd8d577b4daaba2735479a&scene=38#wechat_redirect)

## viewgroup中有个generateLayoutParams方法，什么情况下我们会考虑复写？
获取其他属性数据的时候，如Margin。需要返回一个MarginLayoutParams类。

## lowmemorykiller机制
所有应用进程都是从zygote孵化出来的，记录在AMS中mLruProcesses列表中，由AMS进行统一管理，AMS中会根据进程的状态更新进程对应的oom_adj值，这个值会通过文件传递到kernel中去，kernel有个低内存回收机制，在内存达到一定阀值时会触发清理oom_adj值高的进程腾出更多的内存空间，这就是Lowmemorykiller工作原理。

## 自定义recycleview.layoutmanager步骤

## Dalvik和ART的区别
> [Dalvik和ART的区别](https://www.cnblogs.com/hsqdboke/p/5205635.html)

## Android中ClassLoader和java中有什么关系和区别
Android:
BootClassLoader - PathClassLoader - DexClassLoader 

## requestLayout、invalidate与postInvalidate三者的区别
- requestLayout：修改布局
- postInvalidate：不一定在主线程中执行，因为他内部会通过handle传递到子线程
- invalidate：只能用于UI线程中

## SparseArray
因为ArrayMap与SparseArray内部都使用了二分法进行从小到大的排序，所以当数据量很大的时候，效率至少降低一半，所以谷歌推荐数据量在千级以内时使用ArrayMap与SparseArray，数据量非常大时使用HashMap；
SparseArray的优点：
- 避免了基本数据类型的装箱操作
- 不需要额外的结构体，单个元素的存储成本更低
- 数据量小的情况下，随机访问的效率更高
SparseArray的缺点：
- 插入操作需要复制数组，增删效率降低
- 数据量巨大时，复制数组成本巨大，gc()成本也巨大
- 数据量巨大时，查询效率也会明显下降