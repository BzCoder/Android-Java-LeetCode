## RecyclerView的缓存机制是什么，它和ListView的最大不同是什么？
 [Bugly-Android ListView 与 RecyclerView 对比浅析--缓存机制](https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&mid=2653578065&idx=2&sn=25e64a8bb7b5934cf0ce2e49549a80d6&chksm=84b3b156b3c43840061c28869671da915a25cf3be54891f040a3532e1bb17f9d32e244b79e3f&scene=21##wechat_redirect)

 [RecyclerView 必知必会](https://mp.weixin.qq.com/s/CzrKotyupXbYY6EY2HP_dA)
 
ListView分为两级缓存：
- mActiveViews：用于屏幕内Item快速滑动重用。
- mScrapViews:：用于缓存Adapter内的Item，在Adapter被替换时，mScrapViews就会被清空。

RecyclerView分为四级缓存：
- mAttachedScrap：和mActiveViews功能类似，用于屏幕内Item快速滑动重用。
- mCacheViews：和mScrapViews功能类似，在Adapter被替换时，mCacheViews会被缓存到RecyclerPool。
- mViewCacheExtension：用户自定义缓存。
- mRecyclerPool：mCache不用的会放进这里，还可以多个RecyclerView共用一个mRecyclerPool。

## RecycleView如何优化？
 [RecyclerView 性能优化](https://blankj.com/2018/09/29/optimize-recycler-view/)

## 为什么要使用MultiDex?MultiDex的执行流程？
 [MultiDex（一）之源码解析](https://www.jianshu.com/p/e164ee033928)

MultiDex启动流程:
 - MultiDex入口：MultiDex.install();
 - 进行各种预校验以及获取需要的信息；
 - 重要方法：MultiDexExtractor.load(context, e, dexDir, false)，将Dex文件提取出来。
 - 重要方法：installSecondaryDexes(loader, dexDir, files)，安装提取出来的Dex文件。
 - 制性提取或者源文件发生变化则重新提取，否则直接使用缓存dex文件。
 - 准备Dex缓存的目录，并且删除其中不是以name.apk.classes开头的文件；
 - 每个Dex的提取最多尝试三次；
 - 将Apk源文件进行解压，将其中的非主Dex文件提取为zip文件。
 - 反射获取ClassLoader中的pathList字段；
 - 反射调用DexPathList对象中的makeDexElements方法，将刚刚提取出来的zip文件包装成Element对象；
 - 将包装成的Element对象扩展到DexPathList中的dexElements数组字段里；
 - makeDexElements中有dexopt的操作，是一个耗时的过程，产物是一个优化过的odex文件。
 

## MultiDex对启动速度有什么影响?需要做什么优化？
> [MultiDex（二）之Dex预加载优化](https://www.jianshu.com/p/2891599511ff)

MultiDex为了解决65535问题，会使得app变得卡顿。

App第一次启动时单独开一个额外优化的进程率先进行Dex提取以及DexOpt的操作，与此同时主进程在后台等待，优化的进程执行完毕之后通知主进程继续往下执行，主进程在执行MultiDex.install时发现已经是提前优化好了Dex，直接执行，非常快，毫秒级别，不会造成卡顿，愉快的往下继续执行。

## intent最大传递数据有限制？限制为多少？如果有限制，有什么好的解决方案么？
1MB，把文件写在暂时文件或者数据库。

## 为什么binder在通信时，为什么只需要一次拷贝？
Binder的map函数，会将内核空间直接与用户空间对应，用户空间可以直接访问内核空间的数据
A进程的数据会被直接拷贝到B进程的内核空间（一次拷贝）

## Android的IPC方式
1.bundle ：
简单易用  但是只能传输Bundle支持的对象 常用于四大组件间进程间通信 
2.文件共享：
简单易用  但不适合在高并发的情况下 并且读取文件需要时间 不能即时通信   常用于并发程度不高 并且实时性要求不高的情况
3.AIDL ：
功能强大 支持一对多并发通信 支持即时通信   但是使用起来比其他的复杂 需要处理好多线程的同步问题  常用于一对多通信 且有RPC 需求的场合(服务端和客户端通信)
4.Messenger ：
功能一般 支持一对多串行通信 支持实时通信  但是不能很好处理高并发情况 只能传输Bundle支持的类型  常用于低并发的无RPC需求一对多的场合 
5.ContentProvider ：
在数据源访问方面功能强大 支持一对多并发操作 可扩展call方法  可以理解为约束版的AIDL  提供CRUD操作和自定义函数  常用于一对多的数据共享场合
6.Socket ：
功能强大 可以通过网络传输字节流 支持一对多并发操作  但是实现起来比较麻烦 不支持直接的RPC   常用于网络数据交换

当仅仅是跨进程的四大组件间的传递数据时 使用Bundle就可以  简单方便  
当要共享一个应用程序的内部数据的时候  使用ContentProvider实现比较方便  
当并发程度不高  也就是偶尔访问一次那种 进程间通信 用Messenger就可以  
当设计网络数据的共享时  使用socket 
当需求比较复杂  高并发 并且还要求实时通信 而且有RPC需求时  就得使用AIDL了 
文件共享的方法用于一些缓存共享 之类的功能 

## 匿名内部类，访问外部局部变量，为什么要用final修饰
内部类创建的对象的生命期会超过局部变量，不能让局部变量作用域扩大

## Android 进程间如何高效的传递较大数据块

## transform api和apt,各有什么实用场景，能否相互替换，相互补充？

## Android p限制访问hidden api大致原理？如何绕过？
> [Android P 调用隐藏API限制原理](https://mp.weixin.qq.com/s?__biz=MzUxODQ3MTk5Mg==&mid=2247483899&idx=1&sn=b471ce18b425696dfc5d9805328f1794&chksm=f98929accefea0ba5ecbf0917b71a5cb223f4d875eb769da35740ddd8d577b4daaba2735479a&scene=38#wechat_redirect)

## viewgroup中有个generateLayoutParams方法，什么情况下我们会考虑复写？
获取其他属性数据的时候，如Margin。需要返回一个MarginLayoutParams类。

## lowmemorykiller机制
所有应用进程都是从zygote孵化出来的，记录在AMS中mLruProcesses列表中，由AMS进行统一管理，AMS中会根据进程的状态更新进程对应的oom_adj值，这个值会通过文件传递到kernel中去，kernel有个低内存回收机制，在内存达到一定阀值时会触发清理oom_adj值高的进程腾出更多的内存空间，这就是Lowmemorykiller工作原理。

## 自定义recycleview.layoutmanager步骤

## Dalvik和ART的区别
> [Dalvik和ART的区别](https://www.cnblogs.com/hsqdboke/p/5205635.html)

## Dalvik与Jvm的区别
Dalvik基于寄存器，Jvm基于栈
许多GC实现都是在对象开头的地方留一小块空间给GC标记用。Dalvik VM则不同，在进行GC的时候会单独申请一块空间，以位图的形式来保存整个堆上的对象的标记，在GC结束后就释放该空间。 


## Android中ClassLoader和java中有什么关系和区别
Android:
BootClassLoader - PathClassLoader - DexClassLoader 

## requestLayout、invalidate与postInvalidate三者的区别
- requestLayout：修改布局
- postInvalidate：不一定在主线程中执行，因为他内部会通过handle传递到子线程
- invalidate：只能用于UI线程中

## SparseArray
因为ArrayMap与SparseArray内部都使用了二分法进行从小到大的排序，所以当数据量很大的时候，效率至少降低一半，所以谷歌推荐数据量在千级以内时使用ArrayMap与SparseArray，数据量非常大时使用HashMap；
SparseArray的优点：
- 避免了基本数据类型的装箱操作
- 不需要额外的结构体，单个元素的存储成本更低
- 数据量小的情况下，随机访问的效率更高
SparseArray的缺点：
- 插入操作需要复制数组，增删效率降低
- 数据量巨大时，复制数组成本巨大，gc()成本也巨大
- 数据量巨大时，查询效率也会明显下降

## EventBus
- subscriptionByEventType 订阅时间 -> 所有订阅者
- typesBySubscriber 订阅者 -> 订阅者的事件列表
- SubscriptionMethod 需要回调的方法
- Subscription 记录每个订阅者与回调方法之间的关系
- SubscriptionMethod 被封装的回调方法信息
- SubscriberMethodFinder 它可以在 register 时得到订阅者的所有回调方法，并封装返回给 EventBus
最后的实现调用反射

## Glide缓存机制
- DiskLruCache
- LruCache
- 硬盘缓存

## LruCache原理
LruCache 其实使用了 LinkedHashMap 双向链表结构，当 accessOrder 为 true 时，这个集合的元素顺序就会是访问顺序，也就是访问（Get方法）之后就会将这个元素放到集合的最后面。 put 和 trimToSize 的方法执行下，如果发生数据移除，会优先移除掉头部数据。

## 对Activity启动流程的了解：AMS和ActivityThread涉及到的源码？

## 四种GC方式
- 标记清除算法
- 标记整理算法
- 复制算法
- 分代收集 新生代使用复制算法，老年代使用标记整理

## Android的ClassLoader
主要是两个ClassLoader,都继承与BaseDexClassLoader:
- DexClassLoader:只能加载本App的Dex
- PathClassLoader:可以加载其他文件夹下的Dex文件
https://blog.csdn.net/itermeng/article/details/79350945

## OkHttp
新建OkHttpClient
newCall(request)出realCall
同步直接运行
异步Dispatcher(ExecutorService)
不能运行就放入readyAsyncCalls
能运行就放入runningAsyncCalls
核心责任链模式：
- 在配置OkHttpClient时设置的interceptors
- RetryAndFollowUpInterceptor：负责失败重试以及重定向
- BridgeInterceptor：负责把用户构造的请求转换为发送到服务器的请求、把服务器返回的响应转换为用户友好的响应的
- CacheInterceptor：负责读取缓存直接返回、更新缓存
- ConnectInterceptor：负责和服务器建立连接的
- networkInterceptors：配置OkHttpClient时设置的
- CallServerInterceptor：负责向服务器发送请求数据、从服务器读取响应数据

# OnTouchListener、OnTouchEvent、OnClickListener事件分发顺序
- 调用顺序:OnTouchListener.onTouch（）——>onTouchEvent（）——>OnClickListener.onClick（）

# RxLifecycle原理
https://juejin.im/post/5b4173cfe51d4518f543c874
每个页面实现Lifecycleable接口，配合BehaviorSubject使用，配合BehaviorSubject使用的作用会发射最近的事件，如果没有就发射默认的事件。这样在生命周期发生变化时，就会发送相应的事件。这些其实已经封装在RxAppCompatActivity中了。利用Compose操作符号对Observable进行转换。配合takeUntil使用，takeUntil发送一个事件后，原先的第一个Observable就会停止发送事件。
- 绑定Event直接就是相等的时候就停止发送
- 绑定Lifecycle的时候，利用take,skip,combineLatest三个操作符去控制。

# HTTP1.1 与 HTTP2 的区别
- HTTP2使用的是二进制传送，HTTP1.X是文本（字符串）传送。
- HTTP2支持多路复用
- HTTP2头部压缩
- HTTP2支持服务器推送

# APK瘦身
- lint工具
- 使用WebP图片
- resConfigs去除一些非需要的国际化配置
- 只放xxhdpi图片
- ndk只放需要的
```groovy
buildTypes {
        release {
            buildConfigField 'String', 'TINKER_APP_ID', '"d499a164a6"'
            debuggable false //debug false 
            shrinkResources true //移除无用资源
            zipAlignEnabled true //开启压缩
            resConfigs "zh"  //表示只使用中文
            resConfigs "xhdpi" // 表示只是用xhdpi目录下的资源文件
            minifyEnabled true //开启混淆
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
            signingConfig signingConfigs.release

            ndk {
                //选择要添加的对应cpu类型的.so库。
                abiFilters 'armeabi-v7a'
            }
        }
 }
```

# Action,Data,Category,Extras:
Action:Action属性的值是一个字符串，它代表了系统中定义的一系列常用动作。通过setAction()方法或在清单文件AndroidManifest.xml中设置。默认为：DEFAULT。

Data:Data通常是URL格式定义的操作数据。列如:tel//。通过setData()方法设置。

Category：Category属性用于指定当前动作(Action)被执行的环境。通过addCategory()方法或在清单文件 AndroidManifest.xml中设置.默认为:CATEGORY_DEFAULT。

Extras：主要用于传递目标组件所需要的额外数据。通过putExtras()方法设置.


# Tinker
- Tinker不支持修改AndroidManifest.xml，Tinker不支持新增四大组件；
- 由于Google Play的开发者条款限制，不建议在GP渠道动态更新代码；
- 在Android N上，补丁对应用启动时间有轻微的影响；
- 不支持部分三星android-21机型，加载补丁时会主动抛出"TinkerRuntimeException:checkDexInstall failed"；
- 对于资源替换，不支持修改remoteView。例如transition动画，notification icon以及桌面图标；

三者生成的流程都是：补丁生成，补丁合成，补丁加载
- dex：BaseDexClassLoader
- 资源更新：AssetManager
- so：System.load

# 项目介绍
是一个组件化项目，使用了rxjava2,retrofit,Dagger2,butterknife,Arouter,rxlifecycle,leakcanery,glide，EventBus
- 模块划分问题
- 资源命名问题，以及前缀
- R,R2资源以及switch case 与 if else的问题
- 两套manifest，gradle切换
- 项目配置问题
- 模块个性化配置问题（application，屏幕适配，Activity）
- 全局单例问题
- Dagger2的使用以及坑
- 页面的跳转以及路由问题，以及模块之间的互相调用（Arouter的实现原理）

# Arouter
Arouter是代理类，真正的实现类是_ARouter。
会通过反射建立管理路由的集合
- Arouter$$Interceptores$$app
- Arouter$$Provides$$app
- Arouter$$Root$$app
- xxxx$$Group$$GroupName
- xxxx$$ARouter$$Autowired

navigation
- Activity
如果是Acitvity，则实现Intent跳转
```java
     final Intent intent = new Intent(currentContext, postcard.getDestination());
                intent.putExtras(postcard.getExtras());

                // Set flags.
                int flags = postcard.getFlags();
                if (-1 != flags) {
                    intent.setFlags(flags);
                } else if (!(currentContext instanceof Activity)) {    // Non activity, need less one flag.
                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                }

                // Set Actions
                String action = postcard.getAction();
                if (!TextUtils.isEmpty(action)) {
                    intent.setAction(action);
                }

                // Navigation in main looper.
                runInMainThread(new Runnable() {
                    @Override
                    public void run() {
                        startActivity(requestCode, currentContext, intent, postcard, callback);
                    }
                });

```
- Fragment
fragment是利用反射将其实例化
```java
   Class fragmentMeta = postcard.getDestination();
                try {
                    Object instance = fragmentMeta.getConstructor().newInstance();
                    if (instance instanceof Fragment) {
                        ((Fragment) instance).setArguments(postcard.getExtras());
                    } else if (instance instanceof android.support.v4.app.Fragment) {
                        ((android.support.v4.app.Fragment) instance).setArguments(postcard.getExtras());
                    }

                    return instance;
                } catch (Exception ex) {
                    logger.error(Consts.TAG, "Fetch fragment instance error, " + TextUtils.formatStackTrace(ex.getStackTrace()));
                }
```
- Provider:
Service服务的话，Arouter会在初始化的是将实例设置到Postcard的provider中，使用的时候直接拿出即可

# 进程与线程的区别
- 进程是资源分配和保护的基本单位，线程是处理器调度和分派的基本单位，程序执行的最小单元。
- 同一个进程中可以包含多个线程，并且线程共享整个进程的资源（寄存器、堆栈、上下文），一个进程至少包含一个线程。
- 进程结束后，它所有的线程都将销毁，而线程的结束不会影响同个进程中其他线程的结束。
- 线程是轻量级的进程，它的创建和销毁所需时间和空间都比进程小很多，所有操作系统的执行功能都是创建线程去完成的。
- 线程有自己的私有属性TCB，线程id，寄存器、硬件上下文，而进程也有自己的私有属性进程控制块PCB，这些私有属性是不被共享的，用来标示一个进程或一个线程的标志

# synchronized和ReentrantLock的比较
- Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；
- synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；
- Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；
- 通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。
- Lock可以提高多个线程进行读操作的效率。

# 各个版本适配
> [各个版本适配](https://blog.csdn.net/weixin_38261570/article/details/81046352)

# 热修复
热修复目的是替换有Bug的类。利用的是ClassLoader。
## 一.ClassLoader
Android分为两个主要的ClassLoader:1.DexClassLoader 2.PathClassLoad，他们的父类都为BaseDexClassLoader，其中DexClassLoader可以加载外部文件。我们通过修改DexClassLoader来完成热加载。BaseDexClassLoader中有findClass方法,该方法主要就是为寻找要加载的类的，其中有一个pathList对象，该对象中有一个dexElements，所有的dex都是在dexElements中，我们查找类就是通过遍历dexElements去查找。我们只要把我们生成的补丁文件放在dexElement前面，就可以替换掉原有的类。

## 二.CLASS_ISPREVERIFIED
要注意一个CLASS_ISPREVERIFIED的问题。两个相关联的类在不同的dex中就会校验CLASS_ISPREVERIFIED。在虚拟机启动的时候，当verify选项被打开的时候，如果static方法、private方法、构造函数等，其中的直接引用（第一层关系）到的类都在同一个dex文件中，那么该类就会被打上CLASS_ISPREVERIFIED标志。因为我们的补丁类和LoadBugClass肯定不在一个dex中，所以我们要阻止LoadBugClass.class打上CLASS_ISPREVERIFIED的标签。

## 三.阻止相关类打上CLASS_ISPREVERIFIED标志
在dx工具(将.class文件转化为.dex文件)执行之前，将LoadBugClass.class文件呢，进行修改，再其构造中添加System.out.println(dodola.hackdex.AntilazyLoad.class)，然后继续打包的流程。注意：AntilazyLoad.class这个类是独立在hack.dex中。
我们利用javassist在LoadBugClass加入AntilazyLoad中的方法，在app/build.gradle中设置任务，使其在dx工具之前运行。

## 四.打补丁
我们在Application中的onCreate方法中进行操作，把补丁文件中的Dex合并到dexElements中，通过反射设置到pathList中。

# 插件化
## 代码加载



## 资源加载


## Rxjava2常用操作符
- zip：合并发射器，实现多个接口数据共同更新 UI
- concat：把两个发射器连接成一个发射器，采用 concat 操作符先读取缓存再通过网络请求获取数据
- flatMap：实现多个网络请求依次依赖（无序）
- concatMap：实现多个网络请求依次依赖（有序）
- interval：实现心跳间隔任务
- compose：封装常用操作

## http怎么知道文件过大是否传输完毕的响应
- http协议有正文大小说明的content-length
- 最后一个tcp segment 的话，就会有http header 字段，同时， 数据的最后会有 "0\r\n\r\n" 这个东西，这个东西就表示数据都发送完了。


## TCP与UDP区别
TCP、UDP两者的区别
- TCP是面向连接的（在客户端和服务器之间传输数据之前要先建立连接），UDP是无连接的（发送数据之前不需要先建立连接）
- TCP提供可靠的服务（通过TCP传输的数据。无差错，不丢失，不重复，且按序到达）；UDP提供面向事务的简单的不可靠的传输。
- UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性比较高的通讯或广播通信。随着网速的提高，UDP使用越来越多。
- TCP连接只能是点到点的，UDP支持一对一，一对多和多对多的交互通信。
- TCP对系统资源要去比较多，UDP对系统资源要求比较少
- UDP程序结构更加简单
- TCP是流模式，UDP是数据报模式


## WebView优化
总体：
- 降低请求量：合并资源，减少 HTTP 请求数，minify / gzip 压缩，webP，lazyLoad。
- 加快请求速度：预解析DNS，减少域名数，并行加载，CDN 分发。
- 缓存：HTTP 协议缓存请求，离线缓存 manifest，离线数据缓存 localStorage。
- 渲染：JS/CSS优化，加载顺序，服务端渲染模板直出。

具体优化：
- 预推资源，通过拦截用本地资源替代远程资源。（本地JS，CSS以及图片）
- 使用动态直出技术，利用服务器渲染页面（JS请求在服务端处理完毕后输出）。
- 建立中间层，使得WebView的加载与网络请求并行处理