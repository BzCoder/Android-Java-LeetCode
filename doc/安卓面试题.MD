## RecyclerView的缓存机制是什么，它和ListView的最大不同是什么？
 [Bugly-Android ListView 与 RecyclerView 对比浅析--缓存机制](https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&mid=2653578065&idx=2&sn=25e64a8bb7b5934cf0ce2e49549a80d6&chksm=84b3b156b3c43840061c28869671da915a25cf3be54891f040a3532e1bb17f9d32e244b79e3f&scene=21##wechat_redirect)

 [RecyclerView 必知必会](https://mp.weixin.qq.com/s/CzrKotyupXbYY6EY2HP_dA)
 
ListView分为两级缓存：
- mActiveViews：用于屏幕内Item快速滑动重用。
- mScrapViews:：用于缓存Adapter内的Item，在Adapter被替换时，mScrapViews就会被清空。

RecyclerView分为四级缓存：
- mAttachedScrap：和mActiveViews功能类似，用于屏幕内Item快速滑动重用。
- mCacheViews：和mScrapViews功能类似，在Adapter被替换时，mCacheViews会被缓存到RecyclerPool。
- mViewCacheExtension：用户自定义缓存。
- mRecyclerPool：mCache不用的会放进这里，还可以多个RecyclerView共用一个mRecyclerPool。

## RecycleView如何优化？
 [RecyclerView 性能优化](https://blankj.com/2018/09/29/optimize-recycler-view/)

## 为什么要使用MultiDex?MultiDex的执行流程？
 [MultiDex（一）之源码解析](https://www.jianshu.com/p/e164ee033928)

MultiDex启动流程:
 - MultiDex入口：MultiDex.install();
 - 进行各种预校验以及获取需要的信息；
 - 重要方法：MultiDexExtractor.load(context, e, dexDir, false)，将Dex文件提取出来。
 - 重要方法：installSecondaryDexes(loader, dexDir, files)，安装提取出来的Dex文件。
 - 制性提取或者源文件发生变化则重新提取，否则直接使用缓存dex文件。
 - 准备Dex缓存的目录，并且删除其中不是以name.apk.classes开头的文件；
 - 每个Dex的提取最多尝试三次；
 - 将Apk源文件进行解压，将其中的非主Dex文件提取为zip文件。
 - 反射获取ClassLoader中的pathList字段；
 - 反射调用DexPathList对象中的makeDexElements方法，将刚刚提取出来的zip文件包装成Element对象；
 - 将包装成的Element对象扩展到DexPathList中的dexElements数组字段里；
 - makeDexElements中有dexopt的操作，是一个耗时的过程，产物是一个优化过的odex文件。
 

## MultiDex对启动速度有什么影响?需要做什么优化？
> [MultiDex（二）之Dex预加载优化](https://www.jianshu.com/p/2891599511ff)

MultiDex为了解决65535问题，会使得app变得卡顿。

App第一次启动时单独开一个额外优化的进程率先进行Dex提取以及DexOpt的操作，与此同时主进程在后台等待，优化的进程执行完毕之后通知主进程继续往下执行，主进程在执行MultiDex.install时发现已经是提前优化好了Dex，直接执行，非常快，毫秒级别，不会造成卡顿，愉快的往下继续执行。

## intent最大传递数据有限制？限制为多少？如果有限制，有什么好的解决方案么？
1MB，把文件写在暂时文件或者数据库。

## 为什么binder在通信时，为什么只需要一次拷贝？
Binder的map函数，会将内核空间直接与用户空间对应，用户空间可以直接访问内核空间的数据
A进程的数据会被直接拷贝到B进程的内核空间（一次拷贝）

## Android的IPC方式
1.bundle ：
简单易用  但是只能传输Bundle支持的对象 常用于四大组件间进程间通信 
2.文件共享：
简单易用  但不适合在高并发的情况下 并且读取文件需要时间 不能即时通信   常用于并发程度不高 并且实时性要求不高的情况
3.AIDL ：
功能强大 支持一对多并发通信 支持即时通信   但是使用起来比其他的复杂 需要处理好多线程的同步问题  常用于一对多通信 且有RPC 需求的场合(服务端和客户端通信)
4.Messenger ：
功能一般 支持一对多串行通信 支持实时通信  但是不能很好处理高并发情况 只能传输Bundle支持的类型  常用于低并发的无RPC需求一对多的场合 
5.ContentProvider ：
在数据源访问方面功能强大 支持一对多并发操作 可扩展call方法  可以理解为约束版的AIDL  提供CRUD操作和自定义函数  常用于一对多的数据共享场合
6.Socket ：
功能强大 可以通过网络传输字节流 支持一对多并发操作  但是实现起来比较麻烦 不支持直接的RPC   常用于网络数据交换

当仅仅是跨进程的四大组件间的传递数据时 使用Bundle就可以  简单方便  
当要共享一个应用程序的内部数据的时候  使用ContentProvider实现比较方便  
当并发程度不高  也就是偶尔访问一次那种 进程间通信 用Messenger就可以  
当设计网络数据的共享时  使用socket 
当需求比较复杂  高并发 并且还要求实时通信 而且有RPC需求时  就得使用AIDL了 
文件共享的方法用于一些缓存共享 之类的功能 

## 匿名内部类，访问外部局部变量，为什么要用final修饰
内部类创建的对象的生命期会超过局部变量，不能让局部变量作用域扩大

## Android 进程间如何高效的传递较大数据块

## transform api和apt,各有什么实用场景，能否相互替换，相互补充？

## Android p限制访问hidden api大致原理？如何绕过？
> [Android P 调用隐藏API限制原理](https://mp.weixin.qq.com/s?__biz=MzUxODQ3MTk5Mg==&mid=2247483899&idx=1&sn=b471ce18b425696dfc5d9805328f1794&chksm=f98929accefea0ba5ecbf0917b71a5cb223f4d875eb769da35740ddd8d577b4daaba2735479a&scene=38#wechat_redirect)

## viewgroup中有个generateLayoutParams方法，什么情况下我们会考虑复写？
获取其他属性数据的时候，如Margin。需要返回一个MarginLayoutParams类。

## lowmemorykiller机制
所有应用进程都是从zygote孵化出来的，记录在AMS中mLruProcesses列表中，由AMS进行统一管理，AMS中会根据进程的状态更新进程对应的oom_adj值，这个值会通过文件传递到kernel中去，kernel有个低内存回收机制，在内存达到一定阀值时会触发清理oom_adj值高的进程腾出更多的内存空间，这就是Lowmemorykiller工作原理。

## 自定义recycleview.layoutmanager步骤

## Dalvik和ART的区别
> [Dalvik和ART的区别](https://www.cnblogs.com/hsqdboke/p/5205635.html)

## Dalvik与Jvm的区别
Dalvik基于寄存器，Jvm基于栈

## Android中ClassLoader和java中有什么关系和区别
Android:
BootClassLoader - PathClassLoader - DexClassLoader 

## requestLayout、invalidate与postInvalidate三者的区别
- requestLayout：修改布局
- postInvalidate：不一定在主线程中执行，因为他内部会通过handle传递到子线程
- invalidate：只能用于UI线程中

## SparseArray
因为ArrayMap与SparseArray内部都使用了二分法进行从小到大的排序，所以当数据量很大的时候，效率至少降低一半，所以谷歌推荐数据量在千级以内时使用ArrayMap与SparseArray，数据量非常大时使用HashMap；
SparseArray的优点：
- 避免了基本数据类型的装箱操作
- 不需要额外的结构体，单个元素的存储成本更低
- 数据量小的情况下，随机访问的效率更高
SparseArray的缺点：
- 插入操作需要复制数组，增删效率降低
- 数据量巨大时，复制数组成本巨大，gc()成本也巨大
- 数据量巨大时，查询效率也会明显下降

## EventBus
- subscriptionByEventType 订阅时间 -> 所有订阅者
- typesBySubscriber 订阅者 -> 订阅者的事件列表
- SubscriptionMethod 需要回调的方法
- Subscription 记录每个订阅者与回调方法之间的关系
- SubscriptionMethod 被封装的回调方法信息
- SubscriberMethodFinder 它可以在 register 时得到订阅者的所有回调方法，并封装返回给 EventBus
最后的实现调用反射

## Glide缓存机制
- DiskLruCache
- LruCache
- 硬盘缓存

## LruCache原理
LruCache 其实使用了 LinkedHashMap 双向链表结构，当 accessOrder 为 true 时，这个集合的元素顺序就会是访问顺序，也就是访问（Get方法）之后就会将这个元素放到集合的最后面。 put 和 trimToSize 的方法执行下，如果发生数据移除，会优先移除掉头部数据。

## 对Activity启动流程的了解：AMS和ActivityThread涉及到的源码？

## 四种GC方式
- 标记清除算法
- 标记整理算法
- 复制算法
- 分代收集 新生代使用复制算法，老年代使用标记整理

## Android的ClassLoader
主要是两个ClassLoader,都继承与BaseDexClassLoader:
- DexClassLoader:只能加载本App的Dex
- PathClassLoader:可以加载其他文件夹下的Dex文件
https://blog.csdn.net/itermeng/article/details/79350945

## OkHttp
责任链模式：
- RetryAndFollowInterceptor:请求的重定向操作，用于处理网络请求中，请求失败后的重试机制
- BridgeInterceptor:它首先将客户端构建的Request对象信息构建成真正的网络请求;然后发起网络请求，服务器返回的消息封装成一个Response对象。 
- CacheInterceptor:缓存操作
- ConnectInterceptor:开启对服务器的连接
- CallServerInterceptor:最后的拦截器，发送请求

# OnTouchListener、OnTouchEvent、OnClickListener事件分发顺序
- 调用顺序:OnTouchListener.onTouch（）——>onTouchEvent（）——>OnClickListener.onClick（）

# RxLifecycle原理
https://juejin.im/post/5b4173cfe51d4518f543c874
每个页面实现Lifecycleable接口，配合BehaviorSubject使用，配合BehaviorSubject使用的作用会发射最近的事件，如果没有就发射默认的事件。这样在生命周期发生变化时，就会发送相应的事件。这些其实已经封装在RxAppCompatActivity中了。利用Compose操作符号对Observable进行转换。配合takeUntil使用，takeUntil发送一个事件后，原先的第一个Observable就会停止发送事件。
- 绑定Event直接就是相等的时候就停止发送
- 绑定Lifecycle的时候，利用take,skip,combineLatest三个操作符去控制。

# HTTP1.1 与 HTTP2 的区别
- HTTP2使用的是二进制传送，HTTP1.X是文本（字符串）传送。
- HTTP2支持多路复用
- HTTP2头部压缩
- HTTP2支持服务器推送

# APK瘦身
- lint工具
- 使用WebP图片
- resConfigs去除一些非需要的国际化配置
- 只放xxhdpi图片
- ndk只放需要的
```groovy
buildTypes {
        release {
            buildConfigField 'String', 'TINKER_APP_ID', '"d499a164a6"'
            debuggable false //debug false 
            shrinkResources true //移除无用资源
            zipAlignEnabled true //开启压缩
            resConfigs "zh"  //表示只使用中文
            resConfigs "xhdpi" // 表示只是用xhdpi目录下的资源文件
            minifyEnabled true //开启混淆
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
            signingConfig signingConfigs.release

            ndk {
                //选择要添加的对应cpu类型的.so库。
                abiFilters 'armeabi-v7a'
            }
        }
 }
```

# Action,Data,Category,Extras:
Action:Action属性的值是一个字符串，它代表了系统中定义的一系列常用动作。通过setAction()方法或在清单文件AndroidManifest.xml中设置。默认为：DEFAULT。

Data:Data通常是URL格式定义的操作数据。列如:tel//。通过setData()方法设置。

Category：Category属性用于指定当前动作(Action)被执行的环境。通过addCategory()方法或在清单文件 AndroidManifest.xml中设置.默认为:CATEGORY_DEFAULT。

Extras：主要用于传递目标组件所需要的额外数据。通过putExtras()方法设置.


# Tinker
- Tinker不支持修改AndroidManifest.xml，Tinker不支持新增四大组件；
- 由于Google Play的开发者条款限制，不建议在GP渠道动态更新代码；
- 在Android N上，补丁对应用启动时间有轻微的影响；
- 不支持部分三星android-21机型，加载补丁时会主动抛出"TinkerRuntimeException:checkDexInstall failed"；
- 对于资源替换，不支持修改remoteView。例如transition动画，notification icon以及桌面图标；

三者生成的流程都是：补丁生成，补丁合成，补丁加载
- dex：BaseDexClassLoader
- 资源更新：AssetManager
- so：System.load

# 项目介绍
是一个组件化项目，使用了rxjava2,retrofit,Dagger2,butterknife,Arouter,rxlifecycle,leakcanery,glide，EventBus
- 模块划分问题
- 资源命名问题，以及前缀
- R,R2资源以及switch case 与 if else的问题
- 两套manifest，gradle切换
- 项目配置问题
- 模块个性化配置问题（application，屏幕适配，Activity）
- 全局单例问题
- Dagger2的使用以及坑
- 页面的跳转以及路由问题，以及模块之间的互相调用（Arouter的实现原理）